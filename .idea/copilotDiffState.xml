<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/app/routers/admin.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/routers/admin.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException, status&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import text&#10;from sqlalchemy.exc import SQLAlchemyError&#10;from pydantic import BaseModel&#10;from typing import Optional&#10;&#10;from ..database import get_db&#10;&#10;router = APIRouter(prefix=&quot;/admin&quot;, tags=[&quot;admin&quot;])&#10;&#10;&#10;class CreateUserRequest(BaseModel):&#10;    email: str&#10;    phone: Optional[str] = None&#10;    password: str&#10;&#10;&#10;class UpdateUserRequest(BaseModel):&#10;    # Phone is optional; empty string should be treated as NULL&#10;    phone: Optional[str] = None&#10;    # is_active should be provided explicitly for the stored procedure&#10;    is_active: bool&#10;    # Optional role to grant; pass null to skip role update&#10;    role_id: Optional[int] = None&#10;&#10;&#10;@router.get(&quot;/users&quot;)&#10;def list_users(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;List all users from the database.&quot;&quot;&quot;&#10;    try:&#10;        result = db.execute(text(&quot;SELECT user_id, email, phone_number, is_active, created_at, last_login FROM users&quot;))&#10;        users = []&#10;        for row in result:&#10;            users.append({&#10;                # Frontend expects these keys&#10;                &quot;id&quot;: row.user_id,&#10;                &quot;email&quot;: row.email,&#10;                &quot;phone&quot;: row.phone_number,&#10;                &quot;is_active&quot;: bool(row.is_active),&#10;                &quot;created_at&quot;: str(row.created_at) if row.created_at else None,&#10;                &quot;last_login&quot;: str(row.last_login) if row.last_login else None,&#10;            })&#10;        return users&#10;    except SQLAlchemyError as e:&#10;        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))&#10;&#10;&#10;@router.post(&quot;/users&quot;, status_code=status.HTTP_201_CREATED)&#10;def create_user(payload: CreateUserRequest, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Create a new user by calling the stored procedure sp_create_user.&quot;&quot;&quot;&#10;    try:&#10;        # Call stored procedure: sp_create_user(email, phone, password)&#10;        db.execute(&#10;            text(&quot;CALL sp_create_user(:email, :phone, :password)&quot;),&#10;            {&quot;email&quot;: payload.email, &quot;phone&quot;: payload.phone, &quot;password&quot;: payload.password}&#10;        )&#10;        db.commit()&#10;        return {&quot;message&quot;: &quot;User created successfully&quot;}&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        # Extract the MySQL error message (e.g., &quot;Email already exists&quot;)&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)&#10;&#10;&#10;@router.put(&quot;/users/{user_id}&quot;)&#10;def update_user(user_id: int, payload: UpdateUserRequest, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Update a user by calling the stored procedure sp_update_user.&quot;&quot;&quot;&#10;    try:&#10;        # Normalize empty phone to NULL&#10;        phone = payload.phone if (payload.phone is not None and payload.phone != &quot;&quot;) else None&#10;        # Call stored procedure: sp_update_user(user_id, phone, is_active, role_id)&#10;        db.execute(&#10;            text(&quot;CALL sp_update_user(:user_id, :phone, :is_active, :role_id)&quot;),&#10;            {&quot;user_id&quot;: user_id, &quot;phone&quot;: phone, &quot;is_active&quot;: payload.is_active, &quot;role_id&quot;: payload.role_id}&#10;        )&#10;        db.commit()&#10;        return {&quot;message&quot;: &quot;User updated successfully&quot;}&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)&#10;&#10;&#10;@router.delete(&quot;/users/{user_id}&quot;, status_code=status.HTTP_204_NO_CONTENT)&#10;def delete_user(user_id: int, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Delete a user by calling the stored procedure sp_delete_user.&quot;&quot;&quot;&#10;    try:&#10;        # Call stored procedure: sp_delete_user(user_id)&#10;        db.execute(text(&quot;CALL sp_delete_user(:user_id)&quot;), {&quot;user_id&quot;: user_id})&#10;        db.commit()&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        # Extract the MySQL error message (e.g., &quot;Cannot delete user who owns a group&quot;)&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)&#10;&#10;&#10;@router.get(&quot;/roles&quot;)&#10;def list_roles(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Return all available roles.&quot;&quot;&quot;&#10;    try:&#10;        result = db.execute(text(&quot;SELECT role_id, role_name, description FROM roles&quot;))&#10;        roles = []&#10;        for row in result:&#10;            roles.append({&#10;                &quot;role_id&quot;: row.role_id if hasattr(row, 'role_id') else row[0],&#10;                &quot;role_name&quot;: row.role_name if hasattr(row, 'role_name') else row[1],&#10;                &quot;description&quot;: row.description if hasattr(row, 'description') else row[2],&#10;            })&#10;        return roles&#10;    except SQLAlchemyError as e:&#10;        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))&#10;&#10;&#10;@router.get(&quot;/stats&quot;)&#10;def get_statistics(year: int = 2025, min_posts: int = 0, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Get active users statistics by calling the stored procedure sp_get_active_users.&quot;&quot;&quot;&#10;    try:&#10;        # Call stored procedure: sp_get_active_users(year, min_posts)&#10;        result = db.execute(&#10;            text(&quot;CALL sp_get_active_users(:year, :min_posts)&quot;),&#10;            {&quot;year&quot;: year, &quot;min_posts&quot;: min_posts}&#10;        )&#10;        &#10;        stats = []&#10;        for row in result:&#10;            # Assume the procedure returns: user_id, email, total_posts, activity_score&#10;            stats.append({&#10;                &quot;user_id&quot;: row[0],&#10;                &quot;email&quot;: row[1],&#10;                &quot;total_posts&quot;: row[2],&#10;                &quot;activity_score&quot;: row[3] if len(row) &gt; 3 else None,&#10;            })&#10;        return stats&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=error_msg)&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException, status&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import text&#10;from sqlalchemy.exc import SQLAlchemyError&#10;from pydantic import BaseModel&#10;from typing import Optional&#10;&#10;from ..database import get_db&#10;&#10;router = APIRouter(prefix=&quot;/admin&quot;, tags=[&quot;admin&quot;])&#10;&#10;&#10;class CreateUserRequest(BaseModel):&#10;    email: str&#10;    phone: Optional[str] = None&#10;    password: str&#10;&#10;&#10;class UpdateUserRequest(BaseModel):&#10;    # Phone is optional; empty string should be treated as NULL&#10;    phone: Optional[str] = None&#10;    # is_active should be provided explicitly for the stored procedure&#10;    is_active: bool&#10;    # Optional role to grant; pass null to skip role update&#10;    role_id: Optional[int] = None&#10;&#10;&#10;@router.get(&quot;/users&quot;)&#10;def list_users(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;List all users with their roles (aggregated) from the database.&quot;&quot;&quot;&#10;    try:&#10;        result = db.execute(text(&#10;            &quot;&quot;&quot;&#10;            SELECT &#10;                u.user_id,&#10;                u.email,&#10;                u.phone_number,&#10;                u.is_active,&#10;                u.created_at,&#10;                u.last_login,&#10;                GROUP_CONCAT(r.role_name ORDER BY r.role_name SEPARATOR ', ') AS roles,&#10;                MIN(r.role_id) AS primary_role_id&#10;            FROM users u&#10;            LEFT JOIN user_roles ur ON ur.user_id = u.user_id&#10;            LEFT JOIN roles r ON r.role_id = ur.role_id&#10;            GROUP BY u.user_id&#10;            &quot;&quot;&quot;&#10;        ))&#10;        users = []&#10;        for row in result:&#10;            users.append({&#10;                # Frontend expects these keys&#10;                &quot;id&quot;: row.user_id,&#10;                &quot;email&quot;: row.email,&#10;                &quot;phone&quot;: row.phone_number,&#10;                &quot;is_active&quot;: bool(row.is_active),&#10;                &quot;created_at&quot;: str(row.created_at) if row.created_at else None,&#10;                &quot;last_login&quot;: str(row.last_login) if row.last_login else None,&#10;                # New: roles display and primary role id for preselect&#10;                &quot;roles&quot;: getattr(row, 'roles', None),&#10;                &quot;primary_role_id&quot;: int(row.primary_role_id) if getattr(row, 'primary_role_id', None) is not None else None,&#10;            })&#10;        return users&#10;    except SQLAlchemyError as e:&#10;        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))&#10;&#10;&#10;@router.post(&quot;/users&quot;, status_code=status.HTTP_201_CREATED)&#10;def create_user(payload: CreateUserRequest, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Create a new user by calling the stored procedure sp_create_user.&quot;&quot;&quot;&#10;    try:&#10;        # Call stored procedure: sp_create_user(email, phone, password)&#10;        db.execute(&#10;            text(&quot;CALL sp_create_user(:email, :phone, :password)&quot;),&#10;            {&quot;email&quot;: payload.email, &quot;phone&quot;: payload.phone, &quot;password&quot;: payload.password}&#10;        )&#10;        db.commit()&#10;        return {&quot;message&quot;: &quot;User created successfully&quot;}&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        # Extract the MySQL error message (e.g., &quot;Email already exists&quot;)&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)&#10;&#10;&#10;@router.put(&quot;/users/{user_id}&quot;)&#10;def update_user(user_id: int, payload: UpdateUserRequest, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Update a user by calling the stored procedure sp_update_user.&quot;&quot;&quot;&#10;    try:&#10;        # Normalize empty phone to NULL&#10;        phone = payload.phone if (payload.phone is not None and payload.phone != &quot;&quot;) else None&#10;        # Call stored procedure: sp_update_user(user_id, phone, is_active, role_id)&#10;        db.execute(&#10;            text(&quot;CALL sp_update_user(:user_id, :phone, :is_active, :role_id)&quot;),&#10;            {&quot;user_id&quot;: user_id, &quot;phone&quot;: phone, &quot;is_active&quot;: payload.is_active, &quot;role_id&quot;: payload.role_id}&#10;        )&#10;        db.commit()&#10;        return {&quot;message&quot;: &quot;User updated successfully&quot;}&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)&#10;&#10;&#10;@router.delete(&quot;/users/{user_id}&quot;, status_code=status.HTTP_204_NO_CONTENT)&#10;def delete_user(user_id: int, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Delete a user by calling the stored procedure sp_delete_user.&quot;&quot;&quot;&#10;    try:&#10;        # Call stored procedure: sp_delete_user(user_id)&#10;        db.execute(text(&quot;CALL sp_delete_user(:user_id)&quot;), {&quot;user_id&quot;: user_id})&#10;        db.commit()&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        # Extract the MySQL error message (e.g., &quot;Cannot delete user who owns a group&quot;)&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)&#10;&#10;&#10;@router.get(&quot;/roles&quot;)&#10;def list_roles(db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Return all available roles.&quot;&quot;&quot;&#10;    try:&#10;        result = db.execute(text(&quot;SELECT role_id, role_name, description FROM roles&quot;))&#10;        roles = []&#10;        for row in result:&#10;          roles.append({&#10;              &quot;role_id&quot;: row.role_id if hasattr(row, 'role_id') else row[0],&#10;              &quot;role_name&quot;: row.role_name if hasattr(row, 'role_name') else row[1],&#10;              &quot;description&quot;: row.description if hasattr(row, 'description') else row[2],&#10;          })&#10;        return roles&#10;    except SQLAlchemyError as e:&#10;        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))&#10;&#10;&#10;@router.get(&quot;/stats&quot;)&#10;def get_statistics(year: int = 2025, min_posts: int = 0, db: Session = Depends(get_db)):&#10;    &quot;&quot;&quot;Get active users statistics by calling the stored procedure sp_get_active_users.&quot;&quot;&quot;&#10;    try:&#10;        # Call stored procedure: sp_get_active_users(year, min_posts)&#10;        result = db.execute(&#10;            text(&quot;CALL sp_get_active_users(:year, :min_posts)&quot;),&#10;            {&quot;year&quot;: year, &quot;min_posts&quot;: min_posts}&#10;        )&#10;        &#10;        stats = []&#10;        for row in result:&#10;            # Assume the procedure returns: user_id, email, total_posts, activity_score&#10;            stats.append({&#10;                &quot;user_id&quot;: row[0],&#10;                &quot;email&quot;: row[1],&#10;                &quot;total_posts&quot;: row[2],&#10;                &quot;activity_score&quot;: row[3] if len(row) &gt; 3 else None,&#10;            })&#10;        return stats&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        error_msg = str(e.orig) if hasattr(e, 'orig') else str(e)&#10;        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=error_msg)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>